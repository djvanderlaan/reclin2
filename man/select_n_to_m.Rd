% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_greedy.R, R/select_n_to_m.R
\name{select_greedy}
\alias{select_greedy}
\alias{select_greedy.pairs}
\alias{select_n_to_m}
\alias{select_n_to_m.pairs}
\title{Select matching pairs enforcing one-to-one linkage}
\usage{
select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

\method{select_greedy}{pairs}(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)

select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

\method{select_n_to_m}{pairs}(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE
)
}
\arguments{
\item{pairs}{a \code{pairs} object, such as generated by 
\code{\link{pair_blocking}}}

\item{variable}{the name of the new variable to create in pairs. This will be a
logical variable with a value of \code{TRUE} for the selected pairs.}

\item{score}{name of the score/weight variable of the pairs. When not given
and \code{attr(pairs, "score")} is defined, that is used.}

\item{threshold}{the threshold to apply. Pairs with a score above the 
threshold are selected.}

\item{preselect}{a logical variable with the same length as \code{pairs} has
rows, or the name of such a variable in \code{pairs}. Pairs are only 
selected when \code{preselect} is \code{TRUE}. This interacts with 
\code{threshold} (pairs have to be selected with both conditions).}

\item{id_x}{a integer vector with the same length a the number of rows in 
\code{pairs}, or the name of a column in \code{x}. This vector should 
identify unique objects in \code{x}. When not specified it is assumed that
each element in \code{x} is unique.}

\item{id_y}{a integer vector with the same length a the number of rows in 
\code{pairs}, or the name of a column in \code{y}. This vector should 
identify unique objects in \code{y}. When not specified it is assumed that
each element in \code{y} is unique.}

\item{x}{\code{data.table} with one half of the pairs.}

\item{y}{\code{data.table} with the other half of the pairs.}

\item{inplace}{logical indicating whether \code{pairs} should be modified in place. When
pairs is large this can be more efficient.}
}
\value{
Returns the \code{pairs} with the variable given by \code{variable} added. This
is a logical variable indicating which pairs are selected a matches.
}
\description{
Select matching pairs enforcing one-to-one linkage
}
\details{
Both methods force one-to-one matching. \code{select_greedy} uses a greedy 
algorithm that selects the first pair with the highest weight. 
\code{select_n_to_m} tries to optimise the total weight of all of the 
selected pairs. In general this will result in a better selection. However,
\code{select_n_to_m} uses much more memory and is much slower and, therefore,
can only be used when the number of possible pairs is not too large.
}
\examples{
data("linkexample1", "linkexample2")
pairs <- pair_blocking(linkexample1, linkexample2, "postcode")
pairs <- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model <- problink_em(~ lastname + firstname + address + sex, data = pairs)
pairs <- predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)

# Select pairs with a mpost > 0.5 and force one-to-one linkage
pairs <- select_n_to_m(pairs, "ntom", "mpost", 0.5)
pairs <- select_greedy(pairs, "greedy", "mpost", 0.5)
table(pairs$ntom, pairs$greedy)

}
